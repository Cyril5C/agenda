<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Planning Papou Mamine</title>
    <link rel="stylesheet" href="style.css?v=4">
</head>
<body>
    <table>
        <thead>
            <tr id="dates"></tr>
        </thead>
        <tbody>
            <tr id="content"></tr>
        </tbody>
    </table>

    <div class="bottom-section">
        <div class="galerie" id="galerie"></div>
    </div>

    <script>
        // Fonction pour échapper le HTML et prévenir les XSS
        function escapeHtml(text) {
            if (!text) return '';
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Détecter l'environnement et mettre à jour le titre
        fetch('env.php?t=' + new Date().getTime())
            .then(response => response.json())
            .then(data => {
                if (data.env === 'dev') {
                    document.title = '[DEV] ' + document.title;
                }
            })
            .catch(error => console.error('Erreur chargement environnement:', error));

        const jours = ['Dimanche', 'Lundi', 'Mardi', 'Mercredi', 'Jeudi', 'Vendredi', 'Samedi'];
        const mois = ['janvier', 'février', 'mars', 'avril', 'mai', 'juin', 'juillet', 'août', 'septembre', 'octobre', 'novembre', 'décembre'];

        const datesRow = document.getElementById('dates');
        const contentRow = document.getElementById('content');

        // Fonction pour obtenir la date locale au format YYYY-MM-DD (sans conversion UTC)
        function getLocalDateString(date = new Date()) {
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            return `${year}-${month}-${day}`;
        }

        // Fonction pour logger côté serveur
        function serverLog(level, message, data = null) {
            const payload = { level, message };
            if (data) payload.data = data;

            fetch('client-logs.php', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            }).catch(error => console.error('Erreur log serveur:', error));

            // Logger aussi dans la console
            console.log(`[${level}] ${message}`, data || '');
        }

        // Variable pour stocker les événements actuels
        let currentEventsJson = '';
        let currentDate = getLocalDateString(); // Format YYYY-MM-DD en heure locale

        // Variable globale pour stocker les événements
        let allEvents = [];

        // Logger l'initialisation
        serverLog('INFO', 'Page chargée', { currentDate });

        // Fonction pour charger les événements
        function loadEvents() {
            fetch('api-v2.php?t=' + new Date().getTime())
            .then(response => response.json())
            .then(evenements => {
                // Comparer avec les événements actuels pour détecter un changement
                const newEventsJson = JSON.stringify(evenements || []);
                const newDate = getLocalDateString(); // Format YYYY-MM-DD en heure locale

                // Vérifier si on doit régénérer le tableau
                // IMPORTANT: toujours régénérer si la date a changé, même si les événements sont identiques
                const eventsChanged = newEventsJson !== currentEventsJson;
                const dateChanged = newDate !== currentDate;
                const needsRebuild = eventsChanged || dateChanged;

                if (!needsRebuild) {
                    console.log('Aucun changement, pas de régénération du tableau');
                    return;
                }

                if (dateChanged) {
                    serverLog('INFO', 'Changement de date détecté dans loadEvents()', {
                        oldDate: currentDate,
                        newDate: newDate
                    });
                }
                if (eventsChanged) {
                    serverLog('DEBUG', 'Changement des événements détecté');
                }
                console.log('Événements chargés:', evenements);
                console.log('Régénération du tableau nécessaire');

                // Sauvegarder les événements pour les réutiliser
                allEvents = evenements;
                currentEventsJson = newEventsJson;
                currentDate = newDate;

                // Sauvegarder la cellule d'infos si elle existe
                const existingInfosCell = document.getElementById('infosCell');
                const savedInfosContent = existingInfosCell ? existingInfosCell.innerHTML : '';

                // Vider les anciennes données
                datesRow.innerHTML = '';
                contentRow.innerHTML = '';

                // Créer les colonnes pour les 6 jours glissants à partir d'aujourd'hui (+ 2 colonnes d'infos)
                for (let i = 0; i < 6; i++) {
                    const date = new Date();
                    date.setDate(date.getDate() + i);

                    const jour = jours[date.getDay()];
                    const numeroJour = date.getDate();
                    const nomMois = mois[date.getMonth()];

                    // Format de date YYYY-MM-DD pour comparaison (en heure locale)
                    const dateStr = getLocalDateString(date);

                    const th = document.createElement('th');
                    // Ajouter des labels pour aujourd'hui, demain, après-demain
                    if (i === 0) {
                        th.className = 'aujourd-hui';
                        th.innerHTML = `<span class="label-aujourdhui">Aujourd'hui</span><br>${jour}<br>${numeroJour} ${nomMois}`;
                    } else if (i === 1) {
                        th.className = 'demain';
                        th.innerHTML = `<span class="label-demain">Demain</span><br>${jour}<br>${numeroJour} ${nomMois}`;
                    } else if (i === 2) {
                        th.className = 'apres-demain';
                        th.innerHTML = `<span class="label-apres-demain">Après-demain</span><br>${jour}<br>${numeroJour} ${nomMois}`;
                    } else {
                        th.innerHTML = `${jour}<br>${numeroJour} ${nomMois}`;
                    }
                    datesRow.appendChild(th);

                    const td = document.createElement('td');

                    // Collecter tous les événements (dates fixes et récurrents)
                    const eventsForDay = [];

                    // Ajouter les événements avec date fixe
                    evenements
                        .filter(evt => evt.date === dateStr)
                        .forEach(evt => eventsForDay.push(evt));

                    // Ajouter les événements récurrents
                    evenements
                        .filter(evt => {
                            if (!evt.recurrent) return false;

                            // Format V2 CalDAV: quotidien, hebdomadaire, mensuel, annuel
                            if (typeof evt.recurrent === 'string') {
                                if (evt.recurrent === 'quotidien') {
                                    return true; // Tous les jours
                                }
                                if (evt.recurrent === 'hebdomadaire') {
                                    // Afficher le même jour de la semaine que la date de début
                                    if (evt.date) {
                                        const eventDate = new Date(evt.date + 'T00:00:00');
                                        const eventDayOfWeek = eventDate.getDay(); // 0=Dimanche, 1=Lundi, etc.
                                        const currentDayOfWeek = date.getDay();
                                        return eventDayOfWeek === currentDayOfWeek;
                                    }
                                    return false;
                                }
                                if (evt.recurrent === 'mensuel') {
                                    // Afficher le même jour du mois
                                    if (evt.date) {
                                        const eventDay = new Date(evt.date + 'T00:00:00').getDate();
                                        const currentDay = date.getDate();
                                        return eventDay === currentDay;
                                    }
                                    return false;
                                }
                                if (evt.recurrent === 'annuel') {
                                    // Afficher le même jour et mois chaque année
                                    if (evt.date) {
                                        const eventDate = new Date(evt.date + 'T00:00:00');
                                        return eventDate.getDate() === date.getDate() &&
                                               eventDate.getMonth() === date.getMonth();
                                    }
                                    return false;
                                }
                            }

                            // Format V1 legacy: array de jours ["Lundi", "Mardi"]
                            if (Array.isArray(evt.recurrent)) {
                                return evt.recurrent.includes(jour);
                            }

                            return false;
                        })
                        .forEach(evt => {
                            console.log(`Événement récurrent trouvé pour ${jour}:`, evt);
                            eventsForDay.push(evt);
                        });

                    // Trier par heure (les événements sans heure en PREMIER)
                    eventsForDay
                        .sort((a, b) => {
                            // Si a n'a pas d'heure mais b en a : a vient avant
                            if (!a.heure && b.heure) return -1;
                            // Si b n'a pas d'heure mais a en a : b vient avant
                            if (a.heure && !b.heure) return 1;
                            // Si aucun n'a d'heure : ordre original
                            if (!a.heure && !b.heure) return 0;
                            // Si les deux ont une heure : trier chronologiquement
                            return a.heure.localeCompare(b.heure);
                        })
                        .forEach(evt => {
                            const postit = document.createElement('div');
                            postit.className = 'postit';
                            postit.style.backgroundColor = evt.couleur || '#feff9c';

                            // Ajouter une icône pour les événements récurrents
                            if (evt.recurrent) {
                                const icon = document.createElement('div');
                                icon.className = 'postit-recurrent-icon';
                                icon.textContent = '∞';

                                // Formater le tooltip selon le type de récurrence
                                let tooltipText = 'Événement récurrent';
                                if (typeof evt.recurrent === 'string') {
                                    const labels = {
                                        'quotidien': 'Quotidien (tous les jours)',
                                        'hebdomadaire': 'Hebdomadaire (toutes les semaines)',
                                        'mensuel': 'Mensuel (tous les mois)',
                                        'annuel': 'Annuel (tous les ans)'
                                    };
                                    tooltipText += ' : ' + (labels[evt.recurrent] || evt.recurrent);
                                } else if (Array.isArray(evt.recurrent)) {
                                    tooltipText += ' : ' + evt.recurrent.join(', ');
                                }

                                icon.title = tooltipText;
                                postit.appendChild(icon);
                            }

                            // Afficher l'heure seulement si elle existe
                            if (evt.heure) {
                                const heure = document.createElement('div');
                                heure.className = 'postit-heure';
                                heure.textContent = evt.heure;
                                postit.appendChild(heure);
                            }

                            const titre = document.createElement('div');
                            titre.className = 'postit-titre';
                            titre.textContent = evt.titre;
                            postit.appendChild(titre);

                            // Ajouter bouton de suppression pour les événements récurrents
                            if (evt.recurrent && evt.uid) {
                                const deleteBtn = document.createElement('button');
                                deleteBtn.className = 'postit-delete-occurrence';
                                deleteBtn.textContent = '×';
                                deleteBtn.title = 'Supprimer cette occurrence';
                                deleteBtn.onclick = (e) => {
                                    e.stopPropagation();
                                    if (confirm('Supprimer uniquement cette occurrence du ' + dateStr + ' ?')) {
                                        deleteOccurrence(evt.uid, dateStr);
                                    }
                                };
                                postit.appendChild(deleteBtn);
                            }

                            td.appendChild(postit);
                        });

                    contentRow.appendChild(td);
                }

                // Ajouter l'encart d'informations qui prend 2 colonnes
                const thInfo = document.createElement('th');
                thInfo.colSpan = 2;
                thInfo.className = 'info-header';
                thInfo.innerHTML = 'ℹ️ Informations';
                datesRow.appendChild(thInfo);

                const tdInfo = document.createElement('td');
                tdInfo.colSpan = 2;
                tdInfo.id = 'infosCell';
                tdInfo.className = 'info-cell';
                // Restaurer le contenu sauvegardé pour éviter le clignotement
                if (savedInfosContent) {
                    tdInfo.innerHTML = savedInfosContent;
                }
                contentRow.appendChild(tdInfo);
            })
            .catch(error => console.error('Erreur de chargement des événements:', error));
        }

        // Variable pour stocker la liste actuelle des images
        let currentImagesJson = '';

        // Fonction pour charger les images
        function loadImages() {
            fetch('images.php?t=' + new Date().getTime())
            .then(response => response.json())
            .then(data => {
                // Comparer avec les images actuelles pour détecter un changement
                const newImagesJson = JSON.stringify(data.images || []);

                if (newImagesJson === currentImagesJson) {
                    console.log('Aucun changement dans les images');
                    return; // Pas de changement, on ne recharge pas
                }

                currentImagesJson = newImagesJson;
                console.log('Mise à jour des images détectée');

                const galerie = document.getElementById('galerie');
                galerie.innerHTML = ''; // Vider la galerie

                if (!data.success || !data.images || data.images.length === 0) {
                    console.log('Aucune image à afficher');
                    return;
                }

                // Ajouter une classe selon le nombre d'images
                if (data.images.length === 1) {
                    galerie.classList.add('galerie-single');
                    galerie.classList.remove('galerie-diptych');
                } else if (data.images.length === 2) {
                    galerie.classList.add('galerie-diptych');
                    galerie.classList.remove('galerie-single');
                } else {
                    galerie.classList.remove('galerie-single', 'galerie-diptych');
                }

                data.images.forEach(image => {
                    const img = document.createElement('img');
                    // Échapper l'URL pour éviter javascript: ou data: malveillants
                    const safeUrl = image.url && (image.url.startsWith('http://') || image.url.startsWith('https://'))
                        ? image.url
                        : '';
                    img.src = safeUrl;
                    img.alt = escapeHtml(image.titre) || 'Image';
                    img.title = escapeHtml(image.titre) || '';
                    img.onerror = function() {
                        this.style.display = 'none'; // Masquer les images cassées
                    };
                    galerie.appendChild(img);
                });
            })
            .catch(error => console.error('Erreur de chargement des images:', error));
        }

        // Variable pour stocker les infos actuelles
        let currentInfosJson = '';
        let currentInfosData = null;

        // Fonction pour mettre à jour l'affichage des infos
        function updateInfosDisplay(data) {
            const infosCell = document.getElementById('infosCell');

            if (infosCell) {
                let html = '';

                // Ajouter le texte d'informations s'il existe (échappé pour éviter XSS)
                if (data && data.success && data.texte && data.texte.trim() !== '') {
                    html += `<div class="infos-texte">${escapeHtml(data.texte)}</div>`;
                }

                // Ajouter les 3 prochains événements après J+6 (échappés pour éviter XSS)
                const nextEvents = getNextEvents(3, 6);
                if (nextEvents.length > 0) {
                    html += '<div class="prochains-events">';
                    html += '<div class="prochains-events-titre">Autres événements :</div>';
                    nextEvents.forEach(evt => {
                        html += `<div class="prochain-event">`;
                        html += `<span class="event-date">${escapeHtml(evt.dateFormatted)}</span>`;
                        // Afficher l'heure seulement si elle existe
                        if (evt.heure) {
                            html += ` - <span class="event-heure">${escapeHtml(evt.heure)}</span>`;
                        }
                        html += ` <span class="event-titre">${escapeHtml(evt.titre)}</span>`;
                        html += `</div>`;
                    });
                    html += '</div>';
                }

                infosCell.innerHTML = html;
            }
        }

        // Fonction pour charger les informations diverses
        function loadInfos() {
            fetch('infos.php?t=' + new Date().getTime())
            .then(response => response.json())
            .then(data => {
                // Comparer avec les infos actuelles pour détecter un changement
                const newInfosJson = JSON.stringify(data);

                if (newInfosJson === currentInfosJson) {
                    console.log('Aucun changement dans les infos');
                    // Même si pas de changement, on met à jour l'affichage (car le tableau peut avoir été régénéré)
                    updateInfosDisplay(currentInfosData);
                    return;
                }

                currentInfosJson = newInfosJson;
                currentInfosData = data;
                console.log('Mise à jour des infos détectée');

                updateInfosDisplay(data);
            })
            .catch(error => {
                console.error('Erreur de chargement des informations:', error);
                updateInfosDisplay(null);
            });
        }

        // Fonction pour récupérer les N prochains événements après X jours
        function getNextEvents(count, afterDays) {
            const events = [];
            const startDate = new Date();
            startDate.setDate(startDate.getDate() + afterDays);

            // Parcourir les 30 prochains jours après J+afterDays
            for (let i = 0; i < 30 && events.length < count; i++) {
                const date = new Date(startDate);
                date.setDate(date.getDate() + i);
                const dateStr = getLocalDateString(date); // Format YYYY-MM-DD en heure locale
                const jour = jours[date.getDay()];

                // Collecter les événements de ce jour (uniquement les événements avec date fixe, pas les récurrents)
                const dayEvents = [];

                // Événements avec date fixe uniquement (on exclut les récurrents)
                allEvents
                    .filter(evt => evt.date === dateStr && !evt.recurrent)
                    .forEach(evt => dayEvents.push({
                        ...evt,
                        dateFormatted: `${jour} ${date.getDate()} ${mois[date.getMonth()]}`
                    }));

                // Trier par heure et ajouter
                dayEvents
                    .sort((a, b) => a.heure.localeCompare(b.heure))
                    .forEach(evt => {
                        if (events.length < count) {
                            events.push(evt);
                        }
                    });
            }

            return events;
        }

        // Fonction pour tout recharger
        function refreshAll() {
            console.log('Rafraîchissement des données...', new Date().toLocaleTimeString());

            // Vérifier si la date a changé (passage à minuit)
            const nowDate = getLocalDateString(); // Format YYYY-MM-DD en heure locale
            if (nowDate !== currentDate) {
                serverLog('WARN', 'Changement de jour détecté dans refreshAll(), forçage du rebuild', {
                    oldDate: currentDate,
                    nowDate: nowDate
                });
                // Forcer le rebuild en réinitialisant currentEventsJson
                currentEventsJson = '';
                // NE PAS mettre à jour currentDate ici, laisser loadEvents() le faire
                // pour que la détection de changement de date fonctionne dans loadEvents()
            }

            loadEvents();
            loadImages();
            loadInfos();
        }

        // Fonction pour supprimer une occurrence d'un événement récurrent
        function deleteOccurrence(uid, date) {
            fetch('api-v2.php', {
                method: 'DELETE',
                headers: {
                    'Content-Type': 'application/json',
                },
                credentials: 'include',
                body: JSON.stringify({
                    uid: uid,
                    occurrence_date: date
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    // Forcer le rechargement complet
                    currentEventsJson = '';
                    loadEvents();
                } else {
                    alert('Erreur: ' + (data.error || 'Impossible de supprimer l\'occurrence'));
                }
            })
            .catch(error => {
                console.error('Erreur:', error);
                alert('Erreur lors de la suppression de l\'occurrence');
            });
        }

        // Variable pour stocker la version actuelle
        let currentBuildTime = null;

        // Fonction pour vérifier si une nouvelle version est disponible
        function checkVersion() {
            fetch('version.json?t=' + new Date().getTime())
                .then(response => response.json())
                .then(data => {
                    if (currentBuildTime === null) {
                        // Premier chargement, on stocke la version
                        currentBuildTime = data.buildTime;
                        serverLog('INFO', 'Version initiale chargée', { buildTime: currentBuildTime });
                    } else if (data.buildTime !== currentBuildTime) {
                        // Nouvelle version détectée, on recharge la page
                        serverLog('WARN', 'Nouvelle version détectée, rechargement...', {
                            oldBuildTime: currentBuildTime,
                            newBuildTime: data.buildTime
                        });
                        location.reload(true);
                    }
                })
                .catch(error => {
                    console.error('Erreur lors de la vérification de version:', error);
                    serverLog('ERROR', 'Erreur vérification version', { error: error.message });
                });
        }

        // Chargement initial
        checkVersion();
        refreshAll();

        // Recharger les données toutes les 60 secondes
        setInterval(refreshAll, 60000);

        // Vérifier la version toutes les 5 minutes
        setInterval(checkVersion, 300000);
    </script>
</body>
</html>
