<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Planning Papou Mamine</title>
    <link rel="stylesheet" href="style.css?v=4">
</head>
<body>
    <div id="clock-bar" class="clock-bar"></div>

    <!-- Horloge analogique -->
    <div class="analog-clock">
        <svg viewBox="0 0 200 200" xmlns="http://www.w3.org/2000/svg">
            <!-- Cadran -->
            <circle cx="100" cy="100" r="95" fill="white" stroke="#333" stroke-width="3"/>

            <!-- Chiffres des heures -->
            <text x="100" y="20" text-anchor="middle" dominant-baseline="middle" font-size="16" font-weight="bold" fill="#333">12</text>
            <text x="140" y="31" text-anchor="middle" dominant-baseline="middle" font-size="16" font-weight="bold" fill="#333">1</text>
            <text x="169" y="60" text-anchor="middle" dominant-baseline="middle" font-size="16" font-weight="bold" fill="#333">2</text>
            <text x="180" y="100" text-anchor="middle" dominant-baseline="middle" font-size="16" font-weight="bold" fill="#333">3</text>
            <text x="169" y="140" text-anchor="middle" dominant-baseline="middle" font-size="16" font-weight="bold" fill="#333">4</text>
            <text x="140" y="169" text-anchor="middle" dominant-baseline="middle" font-size="16" font-weight="bold" fill="#333">5</text>
            <text x="100" y="180" text-anchor="middle" dominant-baseline="middle" font-size="16" font-weight="bold" fill="#333">6</text>
            <text x="60" y="169" text-anchor="middle" dominant-baseline="middle" font-size="16" font-weight="bold" fill="#333">7</text>
            <text x="31" y="140" text-anchor="middle" dominant-baseline="middle" font-size="16" font-weight="bold" fill="#333">8</text>
            <text x="20" y="100" text-anchor="middle" dominant-baseline="middle" font-size="16" font-weight="bold" fill="#333">9</text>
            <text x="31" y="60" text-anchor="middle" dominant-baseline="middle" font-size="16" font-weight="bold" fill="#333">10</text>
            <text x="60" y="31" text-anchor="middle" dominant-baseline="middle" font-size="16" font-weight="bold" fill="#333">11</text>

            <!-- Aiguille des heures -->
            <line id="hour-hand" x1="100" y1="100" x2="100" y2="50" stroke="#333" stroke-width="6" stroke-linecap="round"/>

            <!-- Aiguille des minutes -->
            <line id="minute-hand" x1="100" y1="100" x2="100" y2="30" stroke="#666" stroke-width="4" stroke-linecap="round"/>

            <!-- Centre -->
            <circle cx="100" cy="100" r="5" fill="#333"/>
        </svg>
    </div>

    <table>
        <thead>
            <tr id="dates"></tr>
        </thead>
        <tbody>
            <tr id="content"></tr>
        </tbody>
    </table>

    <div class="bottom-section">
        <div class="galerie" id="galerie"></div>
    </div>

    <script>
        // Fonction pour échapper le HTML et prévenir les XSS
        function escapeHtml(text) {
            if (!text) return '';
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Fonction pour mettre à jour l'horloge numérique
        function updateClock() {
            const now = new Date();
            const hours = String(now.getHours()).padStart(2, '0');
            const minutes = String(now.getMinutes()).padStart(2, '0');

            const clockBar = document.getElementById('clock-bar');
            if (clockBar) {
                clockBar.textContent = `${hours}:${minutes}`;
            }
        }

        // Fonction pour mettre à jour l'horloge analogique
        function updateAnalogClock() {
            const now = new Date();
            const hours = now.getHours();
            const minutes = now.getMinutes();

            // Calculer les angles (0° = 12h, sens horaire)
            const minuteAngle = (minutes * 6); // 6° par minute
            const hourAngle = ((hours % 12) * 30) + (minutes * 0.5); // 30° par heure + mouvement fluide

            // Appliquer les rotations
            const hourHand = document.getElementById('hour-hand');
            const minuteHand = document.getElementById('minute-hand');

            if (hourHand) hourHand.style.transform = `rotate(${hourAngle}deg)`;
            if (minuteHand) minuteHand.style.transform = `rotate(${minuteAngle}deg)`;
        }

        // Mettre à jour les horloges immédiatement
        updateClock();
        updateAnalogClock();

        // Mettre à jour les horloges toutes les secondes
        setInterval(() => {
            updateClock();
            updateAnalogClock();
        }, 1000);

        // Fonction pour gérer le mode sombre automatique (20h - 9h)
        function updateDarkMode() {
            // Vérifier si un mode est forcé via l'URL (?mode=sombre ou ?mode=clair)
            const urlParams = new URLSearchParams(window.location.search);
            const modeParam = urlParams.get('mode');

            if (modeParam === 'sombre') {
                // Mode sombre forcé
                document.body.classList.add('dark-mode');
                return;
            } else if (modeParam === 'clair') {
                // Mode clair forcé
                document.body.classList.remove('dark-mode');
                return;
            }

            // Sinon, utiliser la logique horaire normale
            const now = new Date();
            const hour = now.getHours();

            // Mode sombre actif de 20h à 9h (20, 21, 22, 23, 0, 1, 2, 3, 4, 5, 6, 7, 8)
            const isDarkModeTime = hour >= 20 || hour < 9;

            if (isDarkModeTime) {
                document.body.classList.add('dark-mode');
            } else {
                document.body.classList.remove('dark-mode');
            }
        }

        // Appliquer le mode sombre au chargement
        updateDarkMode();

        // Vérifier toutes les minutes si on doit basculer le mode
        setInterval(updateDarkMode, 60000);

        // Détecter l'environnement et mettre à jour le titre
        fetch('env.php?t=' + new Date().getTime())
            .then(response => response.json())
            .then(data => {
                if (data.env === 'dev') {
                    document.title = '[DEV] ' + document.title;
                }
            })
            .catch(error => console.error('Erreur chargement environnement:', error));

        const jours = ['Dimanche', 'Lundi', 'Mardi', 'Mercredi', 'Jeudi', 'Vendredi', 'Samedi'];
        const mois = ['janvier', 'février', 'mars', 'avril', 'mai', 'juin', 'juillet', 'août', 'septembre', 'octobre', 'novembre', 'décembre'];

        const datesRow = document.getElementById('dates');
        const contentRow = document.getElementById('content');

        // Fonction pour obtenir la date locale au format YYYY-MM-DD (sans conversion UTC)
        function getLocalDateString(date = new Date()) {
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            return `${year}-${month}-${day}`;
        }

        // Fonction pour logger côté serveur
        function serverLog(level, message, data = null) {
            const payload = { level, message };
            if (data) payload.data = data;

            fetch('client-logs.php', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            }).catch(error => console.error('Erreur log serveur:', error));

            // Logger aussi dans la console
            console.log(`[${level}] ${message}`, data || '');
        }

        // Variable pour stocker les événements actuels
        let currentEventsJson = '';
        let currentDate = getLocalDateString(); // Format YYYY-MM-DD en heure locale

        // Variable globale pour stocker les événements
        let allEvents = [];

        // Logger l'initialisation
        serverLog('INFO', 'Page chargée', { currentDate });

        // Fonction pour charger les événements
        function loadEvents() {
            fetch('api.php?t=' + new Date().getTime())
            .then(response => response.json())
            .then(evenements => {
                // Comparer avec les événements actuels pour détecter un changement
                const newEventsJson = JSON.stringify(evenements || []);
                const newDate = getLocalDateString(); // Format YYYY-MM-DD en heure locale

                // Vérifier si on doit régénérer le tableau
                // IMPORTANT: toujours régénérer si la date a changé, même si les événements sont identiques
                const eventsChanged = newEventsJson !== currentEventsJson;
                const dateChanged = newDate !== currentDate;
                const needsRebuild = eventsChanged || dateChanged;

                if (!needsRebuild) {
                    console.log('Aucun changement, pas de régénération du tableau');
                    return;
                }

                if (dateChanged) {
                    serverLog('INFO', 'Changement de date détecté dans loadEvents()', {
                        oldDate: currentDate,
                        newDate: newDate
                    });
                }
                if (eventsChanged) {
                    serverLog('DEBUG', 'Changement des événements détecté');
                }
                console.log('Événements chargés:', evenements);
                console.log('Régénération du tableau nécessaire');

                // Sauvegarder les événements pour les réutiliser
                allEvents = evenements;
                currentEventsJson = newEventsJson;
                currentDate = newDate;

                // Sauvegarder la cellule d'infos si elle existe
                const existingInfosCell = document.getElementById('infosCell');
                const savedInfosContent = existingInfosCell ? existingInfosCell.innerHTML : '';

                // Vider les anciennes données
                datesRow.innerHTML = '';
                contentRow.innerHTML = '';

                // Créer les colonnes pour les 6 jours glissants à partir d'aujourd'hui (+ 2 colonnes d'infos)
                for (let i = 0; i < 6; i++) {
                    const date = new Date();
                    date.setDate(date.getDate() + i);

                    const jour = jours[date.getDay()];
                    const numeroJour = date.getDate();
                    const nomMois = mois[date.getMonth()];

                    // Format de date YYYY-MM-DD pour comparaison (en heure locale)
                    const dateStr = getLocalDateString(date);

                    const th = document.createElement('th');
                    // Ajouter des labels pour aujourd'hui, demain, après-demain
                    if (i === 0) {
                        th.className = 'aujourd-hui';
                        th.innerHTML = `<span class="label-aujourdhui">Aujourd'hui</span><br>${jour}<br>${numeroJour} ${nomMois}`;
                    } else if (i === 1) {
                        th.className = 'demain';
                        th.innerHTML = `<span class="label-demain">Demain</span><br>${jour}<br>${numeroJour} ${nomMois}`;
                    } else if (i === 2) {
                        th.className = 'apres-demain';
                        th.innerHTML = `<span class="label-apres-demain">Après-demain</span><br>${jour}<br>${numeroJour} ${nomMois}`;
                    } else {
                        th.innerHTML = `${jour}<br>${numeroJour} ${nomMois}`;
                    }
                    datesRow.appendChild(th);

                    const td = document.createElement('td');

                    // Collecter tous les événements (dates fixes et récurrents)
                    const eventsForDay = [];

                    // Ajouter les événements avec date fixe
                    evenements
                        .filter(evt => evt.date === dateStr)
                        .forEach(evt => eventsForDay.push(evt));

                    // Ajouter les événements récurrents
                    evenements
                        .filter(evt => evt.recurrent && evt.recurrent.includes(jour))
                        .forEach(evt => {
                            console.log(`Événement récurrent trouvé pour ${jour}:`, evt);
                            eventsForDay.push(evt);
                        });

                    // Trier par heure (les événements sans heure en PREMIER)
                    eventsForDay
                        .sort((a, b) => {
                            // Si a n'a pas d'heure mais b en a : a vient avant
                            if (!a.heure && b.heure) return -1;
                            // Si b n'a pas d'heure mais a en a : b vient avant
                            if (a.heure && !b.heure) return 1;
                            // Si aucun n'a d'heure : ordre original
                            if (!a.heure && !b.heure) return 0;
                            // Si les deux ont une heure : trier chronologiquement
                            return a.heure.localeCompare(b.heure);
                        })
                        .forEach(evt => {
                            const postit = document.createElement('div');
                            postit.className = 'postit';
                            postit.style.backgroundColor = evt.couleur || '#feff9c';

                            // Ajouter une icône pour les événements récurrents
                            if (evt.recurrent) {
                                const icon = document.createElement('div');
                                icon.className = 'postit-recurrent-icon';
                                icon.textContent = '∞';
                                icon.title = 'Événement récurrent : ' + evt.recurrent.join(', ');
                                postit.appendChild(icon);
                            }

                            // Afficher l'heure seulement si elle existe
                            if (evt.heure) {
                                const heure = document.createElement('div');
                                heure.className = 'postit-heure';
                                heure.textContent = evt.heure;
                                postit.appendChild(heure);
                            }

                            const titre = document.createElement('div');
                            titre.className = 'postit-titre';
                            titre.textContent = evt.titre;
                            postit.appendChild(titre);

                            td.appendChild(postit);
                        });

                    contentRow.appendChild(td);
                }

                // Ajouter l'encart d'informations qui prend 2 colonnes
                const thInfo = document.createElement('th');
                thInfo.colSpan = 2;
                thInfo.className = 'info-header';
                thInfo.innerHTML = 'ℹ️ Informations';
                datesRow.appendChild(thInfo);

                const tdInfo = document.createElement('td');
                tdInfo.colSpan = 2;
                tdInfo.id = 'infosCell';
                tdInfo.className = 'info-cell';
                // Restaurer le contenu sauvegardé pour éviter le clignotement
                if (savedInfosContent) {
                    tdInfo.innerHTML = savedInfosContent;
                }
                contentRow.appendChild(tdInfo);
            })
            .catch(error => console.error('Erreur de chargement des événements:', error));
        }

        // Variable pour stocker la liste actuelle des images
        let currentImagesJson = '';

        // Fonction pour charger les images
        function loadImages() {
            fetch('images.php?t=' + new Date().getTime())
            .then(response => response.json())
            .then(data => {
                // Comparer avec les images actuelles pour détecter un changement
                const newImagesJson = JSON.stringify(data.images || []);

                if (newImagesJson === currentImagesJson) {
                    console.log('Aucun changement dans les images');
                    return; // Pas de changement, on ne recharge pas
                }

                currentImagesJson = newImagesJson;
                console.log('Mise à jour des images détectée');

                const galerie = document.getElementById('galerie');
                galerie.innerHTML = ''; // Vider la galerie

                if (!data.success || !data.images || data.images.length === 0) {
                    console.log('Aucune image à afficher');
                    return;
                }

                // Ajouter une classe selon le nombre d'images
                if (data.images.length === 1) {
                    galerie.classList.add('galerie-single');
                    galerie.classList.remove('galerie-diptych');
                } else if (data.images.length === 2) {
                    galerie.classList.add('galerie-diptych');
                    galerie.classList.remove('galerie-single');
                } else {
                    galerie.classList.remove('galerie-single', 'galerie-diptych');
                }

                data.images.forEach(image => {
                    const img = document.createElement('img');
                    // Échapper l'URL pour éviter javascript: ou data: malveillants
                    const safeUrl = image.url && (image.url.startsWith('http://') || image.url.startsWith('https://'))
                        ? image.url
                        : '';
                    img.src = safeUrl;
                    img.alt = escapeHtml(image.titre) || 'Image';
                    img.title = escapeHtml(image.titre) || '';
                    img.onerror = function() {
                        this.style.display = 'none'; // Masquer les images cassées
                    };
                    galerie.appendChild(img);
                });
            })
            .catch(error => console.error('Erreur de chargement des images:', error));
        }

        // Variable pour stocker les infos actuelles
        let currentInfosJson = '';
        let currentInfosData = null;

        // Fonction pour mettre à jour l'affichage des infos
        function updateInfosDisplay(data) {
            const infosCell = document.getElementById('infosCell');

            if (infosCell) {
                let html = '';

                // Ajouter le texte d'informations s'il existe (échappé pour éviter XSS)
                if (data && data.success && data.texte && data.texte.trim() !== '') {
                    html += `<div class="infos-texte">${escapeHtml(data.texte)}</div>`;
                }

                // Ajouter les 3 prochains événements après J+6 (échappés pour éviter XSS)
                const nextEvents = getNextEvents(3, 6);
                if (nextEvents.length > 0) {
                    html += '<div class="prochains-events">';
                    html += '<div class="prochains-events-titre">Autres événements :</div>';
                    nextEvents.forEach(evt => {
                        html += `<div class="prochain-event">`;
                        html += `<span class="event-date">${escapeHtml(evt.dateFormatted)}</span>`;
                        // Afficher l'heure seulement si elle existe
                        if (evt.heure) {
                            html += ` - <span class="event-heure">${escapeHtml(evt.heure)}</span>`;
                        }
                        html += ` <span class="event-titre">${escapeHtml(evt.titre)}</span>`;
                        html += `</div>`;
                    });
                    html += '</div>';
                }

                infosCell.innerHTML = html;
            }
        }

        // Fonction pour charger les informations diverses
        function loadInfos() {
            fetch('infos.php?t=' + new Date().getTime())
            .then(response => response.json())
            .then(data => {
                // Comparer avec les infos actuelles pour détecter un changement
                const newInfosJson = JSON.stringify(data);

                if (newInfosJson === currentInfosJson) {
                    console.log('Aucun changement dans les infos');
                    // Même si pas de changement, on met à jour l'affichage (car le tableau peut avoir été régénéré)
                    updateInfosDisplay(currentInfosData);
                    return;
                }

                currentInfosJson = newInfosJson;
                currentInfosData = data;
                console.log('Mise à jour des infos détectée');

                updateInfosDisplay(data);
            })
            .catch(error => {
                console.error('Erreur de chargement des informations:', error);
                updateInfosDisplay(null);
            });
        }

        // Fonction pour récupérer les N prochains événements après X jours
        function getNextEvents(count, afterDays) {
            const events = [];
            const startDate = new Date();
            startDate.setDate(startDate.getDate() + afterDays);

            // Parcourir les 30 prochains jours après J+afterDays
            for (let i = 0; i < 30 && events.length < count; i++) {
                const date = new Date(startDate);
                date.setDate(date.getDate() + i);
                const dateStr = getLocalDateString(date); // Format YYYY-MM-DD en heure locale
                const jour = jours[date.getDay()];

                // Collecter les événements de ce jour (uniquement les événements avec date fixe, pas les récurrents)
                const dayEvents = [];

                // Événements avec date fixe uniquement (on exclut les récurrents)
                allEvents
                    .filter(evt => evt.date === dateStr && !evt.recurrent)
                    .forEach(evt => dayEvents.push({
                        ...evt,
                        dateFormatted: `${jour} ${date.getDate()} ${mois[date.getMonth()]}`
                    }));

                // Trier par heure et ajouter
                dayEvents
                    .sort((a, b) => a.heure.localeCompare(b.heure))
                    .forEach(evt => {
                        if (events.length < count) {
                            events.push(evt);
                        }
                    });
            }

            return events;
        }

        // Fonction pour tout recharger
        function refreshAll() {
            console.log('Rafraîchissement des données...', new Date().toLocaleTimeString());

            // Vérifier si la date a changé (passage à minuit)
            const nowDate = getLocalDateString(); // Format YYYY-MM-DD en heure locale
            if (nowDate !== currentDate) {
                serverLog('WARN', 'Changement de jour détecté dans refreshAll(), forçage du rebuild', {
                    oldDate: currentDate,
                    nowDate: nowDate
                });
                // Forcer le rebuild en réinitialisant currentEventsJson
                currentEventsJson = '';
                // NE PAS mettre à jour currentDate ici, laisser loadEvents() le faire
                // pour que la détection de changement de date fonctionne dans loadEvents()
            }

            loadEvents();
            loadImages();
            loadInfos();
        }

        // Variable pour stocker la version actuelle
        let currentBuildTime = null;

        // Fonction pour vérifier si une nouvelle version est disponible
        function checkVersion() {
            fetch('version.json?t=' + new Date().getTime())
                .then(response => response.json())
                .then(data => {
                    if (currentBuildTime === null) {
                        // Premier chargement, on stocke la version
                        currentBuildTime = data.buildTime;
                        serverLog('INFO', 'Version initiale chargée', { buildTime: currentBuildTime });
                    } else if (data.buildTime !== currentBuildTime) {
                        // Nouvelle version détectée, on recharge la page
                        serverLog('WARN', 'Nouvelle version détectée, rechargement...', {
                            oldBuildTime: currentBuildTime,
                            newBuildTime: data.buildTime
                        });
                        location.reload(true);
                    }
                })
                .catch(error => {
                    console.error('Erreur lors de la vérification de version:', error);
                    serverLog('ERROR', 'Erreur vérification version', { error: error.message });
                });
        }

        // Chargement initial
        checkVersion();
        refreshAll();

        // Recharger les données toutes les 60 secondes
        setInterval(refreshAll, 60000);

        // Vérifier la version toutes les 5 minutes
        setInterval(checkVersion, 300000);
    </script>
</body>
</html>
