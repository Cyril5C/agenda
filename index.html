<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Planning Papou Mamine</title>
    <link rel="stylesheet" href="style.css?v=4">
</head>
<body>
    <table>
        <thead>
            <tr id="dates"></tr>
        </thead>
        <tbody>
            <tr id="content"></tr>
        </tbody>
    </table>

    <div class="bottom-section">
        <div class="galerie" id="galerie"></div>
    </div>

    <script>
        // Fonction pour échapper le HTML et prévenir les XSS
        function escapeHtml(text) {
            if (!text) return '';
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Détecter l'environnement et mettre à jour le titre
        fetch('env.php?t=' + new Date().getTime())
            .then(response => response.json())
            .then(data => {
                if (data.env === 'dev') {
                    document.title = '[DEV] ' + document.title;
                }
            })
            .catch(error => console.error('Erreur chargement environnement:', error));

        const jours = ['Dimanche', 'Lundi', 'Mardi', 'Mercredi', 'Jeudi', 'Vendredi', 'Samedi'];
        const mois = ['janvier', 'février', 'mars', 'avril', 'mai', 'juin', 'juillet', 'août', 'septembre', 'octobre', 'novembre', 'décembre'];

        const datesRow = document.getElementById('dates');
        const contentRow = document.getElementById('content');

        // Variable pour stocker les événements actuels
        let currentEventsJson = '';
        let currentDate = new Date().toDateString();

        // Variable globale pour stocker les événements
        let allEvents = [];

        // Fonction pour charger les événements
        function loadEvents() {
            fetch('api.php?t=' + new Date().getTime())
            .then(response => response.json())
            .then(evenements => {
                // Comparer avec les événements actuels pour détecter un changement
                const newEventsJson = JSON.stringify(evenements || []);
                const newDate = new Date().toDateString();

                // Vérifier si on doit régénérer le tableau
                const needsRebuild = (newEventsJson !== currentEventsJson) || (newDate !== currentDate);

                if (!needsRebuild) {
                    console.log('Aucun changement, pas de régénération du tableau');
                    return;
                }

                console.log('Événements chargés:', evenements);
                console.log('Régénération du tableau nécessaire');

                // Sauvegarder les événements pour les réutiliser
                allEvents = evenements;
                currentEventsJson = newEventsJson;
                currentDate = newDate;

                // Sauvegarder la cellule d'infos si elle existe
                const existingInfosCell = document.getElementById('infosCell');
                const savedInfosContent = existingInfosCell ? existingInfosCell.innerHTML : '';

                // Vider les anciennes données
                datesRow.innerHTML = '';
                contentRow.innerHTML = '';

                // Créer les colonnes pour les 6 jours glissants à partir d'aujourd'hui (+ 2 colonnes d'infos)
                for (let i = 0; i < 6; i++) {
                    const date = new Date();
                    date.setDate(date.getDate() + i);

                    const jour = jours[date.getDay()];
                    const numeroJour = date.getDate();
                    const nomMois = mois[date.getMonth()];

                    // Format de date YYYY-MM-DD pour comparaison
                    const dateStr = date.toISOString().split('T')[0];

                    const th = document.createElement('th');
                    // Ajouter des labels pour aujourd'hui, demain, après-demain
                    if (i === 0) {
                        th.className = 'aujourd-hui';
                        th.innerHTML = `<span class="label-aujourdhui">Aujourd'hui</span><br>${jour}<br>${numeroJour} ${nomMois}`;
                    } else if (i === 1) {
                        th.className = 'demain';
                        th.innerHTML = `<span class="label-demain">Demain</span><br>${jour}<br>${numeroJour} ${nomMois}`;
                    } else if (i === 2) {
                        th.className = 'apres-demain';
                        th.innerHTML = `<span class="label-apres-demain">Après-demain</span><br>${jour}<br>${numeroJour} ${nomMois}`;
                    } else {
                        th.innerHTML = `${jour}<br>${numeroJour} ${nomMois}`;
                    }
                    datesRow.appendChild(th);

                    const td = document.createElement('td');

                    // Collecter tous les événements (dates fixes et récurrents)
                    const eventsForDay = [];

                    // Ajouter les événements avec date fixe
                    evenements
                        .filter(evt => evt.date === dateStr)
                        .forEach(evt => eventsForDay.push(evt));

                    // Ajouter les événements récurrents
                    evenements
                        .filter(evt => evt.recurrent && evt.recurrent.includes(jour))
                        .forEach(evt => {
                            console.log(`Événement récurrent trouvé pour ${jour}:`, evt);
                            eventsForDay.push(evt);
                        });

                    // Trier par heure (les événements sans heure en PREMIER)
                    eventsForDay
                        .sort((a, b) => {
                            // Si a n'a pas d'heure mais b en a : a vient avant
                            if (!a.heure && b.heure) return -1;
                            // Si b n'a pas d'heure mais a en a : b vient avant
                            if (a.heure && !b.heure) return 1;
                            // Si aucun n'a d'heure : ordre original
                            if (!a.heure && !b.heure) return 0;
                            // Si les deux ont une heure : trier chronologiquement
                            return a.heure.localeCompare(b.heure);
                        })
                        .forEach(evt => {
                            const postit = document.createElement('div');
                            postit.className = 'postit';
                            postit.style.backgroundColor = evt.couleur || '#feff9c';

                            // Ajouter une icône pour les événements récurrents
                            if (evt.recurrent) {
                                const icon = document.createElement('div');
                                icon.className = 'postit-recurrent-icon';
                                icon.textContent = '∞';
                                icon.title = 'Événement récurrent : ' + evt.recurrent.join(', ');
                                postit.appendChild(icon);
                            }

                            // Afficher l'heure seulement si elle existe
                            if (evt.heure) {
                                const heure = document.createElement('div');
                                heure.className = 'postit-heure';
                                heure.textContent = evt.heure;
                                postit.appendChild(heure);
                            }

                            const titre = document.createElement('div');
                            titre.className = 'postit-titre';
                            titre.textContent = evt.titre;
                            postit.appendChild(titre);

                            td.appendChild(postit);
                        });

                    contentRow.appendChild(td);
                }

                // Ajouter l'encart d'informations qui prend 2 colonnes
                const thInfo = document.createElement('th');
                thInfo.colSpan = 2;
                thInfo.className = 'info-header';
                thInfo.innerHTML = 'ℹ️ Informations';
                datesRow.appendChild(thInfo);

                const tdInfo = document.createElement('td');
                tdInfo.colSpan = 2;
                tdInfo.id = 'infosCell';
                tdInfo.className = 'info-cell';
                // Restaurer le contenu sauvegardé pour éviter le clignotement
                if (savedInfosContent) {
                    tdInfo.innerHTML = savedInfosContent;
                }
                contentRow.appendChild(tdInfo);
            })
            .catch(error => console.error('Erreur de chargement des événements:', error));
        }

        // Variable pour stocker la liste actuelle des images
        let currentImagesJson = '';

        // Fonction pour charger les images
        function loadImages() {
            fetch('images.php?t=' + new Date().getTime())
            .then(response => response.json())
            .then(data => {
                // Comparer avec les images actuelles pour détecter un changement
                const newImagesJson = JSON.stringify(data.images || []);

                if (newImagesJson === currentImagesJson) {
                    console.log('Aucun changement dans les images');
                    return; // Pas de changement, on ne recharge pas
                }

                currentImagesJson = newImagesJson;
                console.log('Mise à jour des images détectée');

                const galerie = document.getElementById('galerie');
                galerie.innerHTML = ''; // Vider la galerie

                if (!data.success || !data.images || data.images.length === 0) {
                    console.log('Aucune image à afficher');
                    return;
                }

                // Ajouter une classe si une seule image
                if (data.images.length === 1) {
                    galerie.classList.add('galerie-single');
                } else {
                    galerie.classList.remove('galerie-single');
                }

                data.images.forEach(image => {
                    const img = document.createElement('img');
                    // Échapper l'URL pour éviter javascript: ou data: malveillants
                    const safeUrl = image.url && (image.url.startsWith('http://') || image.url.startsWith('https://'))
                        ? image.url
                        : '';
                    img.src = safeUrl;
                    img.alt = escapeHtml(image.titre) || 'Image';
                    img.title = escapeHtml(image.titre) || '';
                    img.onerror = function() {
                        this.style.display = 'none'; // Masquer les images cassées
                    };
                    galerie.appendChild(img);
                });
            })
            .catch(error => console.error('Erreur de chargement des images:', error));
        }

        // Variable pour stocker les infos actuelles
        let currentInfosJson = '';
        let currentInfosData = null;

        // Fonction pour mettre à jour l'affichage des infos
        function updateInfosDisplay(data) {
            const infosCell = document.getElementById('infosCell');

            if (infosCell) {
                let html = '';

                // Ajouter le texte d'informations s'il existe (échappé pour éviter XSS)
                if (data && data.success && data.texte && data.texte.trim() !== '') {
                    html += `<div class="infos-texte">${escapeHtml(data.texte)}</div>`;
                }

                // Ajouter les 3 prochains événements après J+6 (échappés pour éviter XSS)
                const nextEvents = getNextEvents(3, 6);
                if (nextEvents.length > 0) {
                    html += '<div class="prochains-events">';
                    html += '<div class="prochains-events-titre">Autres événements :</div>';
                    nextEvents.forEach(evt => {
                        html += `<div class="prochain-event">`;
                        html += `<span class="event-date">${escapeHtml(evt.dateFormatted)}</span>`;
                        // Afficher l'heure seulement si elle existe
                        if (evt.heure) {
                            html += ` - <span class="event-heure">${escapeHtml(evt.heure)}</span>`;
                        }
                        html += ` <span class="event-titre">${escapeHtml(evt.titre)}</span>`;
                        html += `</div>`;
                    });
                    html += '</div>';
                }

                infosCell.innerHTML = html;
            }
        }

        // Fonction pour charger les informations diverses
        function loadInfos() {
            fetch('infos.php?t=' + new Date().getTime())
            .then(response => response.json())
            .then(data => {
                // Comparer avec les infos actuelles pour détecter un changement
                const newInfosJson = JSON.stringify(data);

                if (newInfosJson === currentInfosJson) {
                    console.log('Aucun changement dans les infos');
                    // Même si pas de changement, on met à jour l'affichage (car le tableau peut avoir été régénéré)
                    updateInfosDisplay(currentInfosData);
                    return;
                }

                currentInfosJson = newInfosJson;
                currentInfosData = data;
                console.log('Mise à jour des infos détectée');

                updateInfosDisplay(data);
            })
            .catch(error => {
                console.error('Erreur de chargement des informations:', error);
                updateInfosDisplay(null);
            });
        }

        // Fonction pour récupérer les N prochains événements après X jours
        function getNextEvents(count, afterDays) {
            const events = [];
            const startDate = new Date();
            startDate.setDate(startDate.getDate() + afterDays);

            // Parcourir les 30 prochains jours après J+afterDays
            for (let i = 0; i < 30 && events.length < count; i++) {
                const date = new Date(startDate);
                date.setDate(date.getDate() + i);
                const dateStr = date.toISOString().split('T')[0];
                const jour = jours[date.getDay()];

                // Collecter les événements de ce jour (uniquement les événements avec date fixe, pas les récurrents)
                const dayEvents = [];

                // Événements avec date fixe uniquement (on exclut les récurrents)
                allEvents
                    .filter(evt => evt.date === dateStr && !evt.recurrent)
                    .forEach(evt => dayEvents.push({
                        ...evt,
                        dateFormatted: `${jour} ${date.getDate()} ${mois[date.getMonth()]}`
                    }));

                // Trier par heure et ajouter
                dayEvents
                    .sort((a, b) => a.heure.localeCompare(b.heure))
                    .forEach(evt => {
                        if (events.length < count) {
                            events.push(evt);
                        }
                    });
            }

            return events;
        }

        // Fonction pour tout recharger
        function refreshAll() {
            console.log('Rafraîchissement des données...', new Date().toLocaleTimeString());
            loadEvents();
            loadImages();
            loadInfos();
        }

        // Chargement initial
        refreshAll();

        // Recharger les données toutes les 60 secondes
        setInterval(refreshAll, 60000);
    </script>
</body>
</html>
